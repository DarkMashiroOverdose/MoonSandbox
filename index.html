<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>RTS Game with Shaders</title>
    <script src="/target/js/release/build/MoonSandbox.js" defer></script>
    <style>
        body { margin: 0; background-color: #1a1a1a; display: flex;
               justify-content: center; align-items: center; height: 100vh; }
        #canvas-container { position: relative; }
        canvas { position: absolute; top: 0; left: 0; }
        /* 隐藏 Selene 的原始画布，只显示我们的特效画布 */
        #selene-canvas { visibility: hidden; }
    </style>
</head>
<body>
    <div id="canvas-container" style="width: 800px; height: 600px;">
        <canvas id="canvas" width="800" height="600"></canvas>
        <canvas id="fx-canvas" width="800" height="600"></canvas>
    </div>

    <script id="vertex-shader" type="x-shader/x-vertex">
        attribute vec4 aVertexPosition;
        attribute vec2 aTextureCoord;
        varying highp vec2 vTextureCoord;
        void main(void) {
            gl_Position = aVertexPosition;
            vTextureCoord = aTextureCoord;
        }
    </script>
    <script id="fragment-shader-pixelate" type="x-shader/x-fragment">
        varying highp vec2 vTextureCoord;
        uniform sampler2D uSampler;
        uniform highp float u_pixel_size;
        uniform highp vec2 u_resolution;
        void main(void) {
            highp vec2 pixel_grid_size = u_pixel_size / u_resolution;
            highp vec2 snapped_coord = floor(vTextureCoord / pixel_grid_size) * pixel_grid_size;
            highp vec4 color = texture2D(uSampler, snapped_coord);
            gl_FragColor = color;
        }
    </script>

    <script>
        // WebGL 辅助函数 (initWebGL, renderWebGL, loadShader)
        let gl; let shaderProgram; let positionBuffer; let textureCoordBuffer;
        let gameTexture; let pixelSizeUniformLocation; let pixelSize = 4.0;
        function initWebGL(gameCanvas) {
            const fxCanvas = document.getElementById('fx-canvas');
            gl = fxCanvas.getContext('webgl', { premultipliedAlpha: false });
            const vsSource = document.getElementById('vertex-shader').textContent;
            const fsSource = document.getElementById('fragment-shader-pixelate').textContent;
            const vertexShader = loadShader(gl, gl.VERTEX_SHADER, vsSource);
            const fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fsSource);
            shaderProgram = gl.createProgram();
            gl.attachShader(shaderProgram, vertexShader);
            gl.attachShader(shaderProgram, fragmentShader);
            gl.linkProgram(shaderProgram);
            gl.useProgram(shaderProgram);
            pixelSizeUniformLocation = gl.getUniformLocation(shaderProgram, "u_pixel_size");
            const resolutionUniformLocation = gl.getUniformLocation(shaderProgram, "u_resolution");
            gl.uniform2f(resolutionUniformLocation, gl.canvas.width, gl.canvas.height);
            positionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,1,1,1,-1,-1,1,-1]), gl.STATIC_DRAW);
            textureCoordBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, textureCoordBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0,1,1,1,0,0,1,0]), gl.STATIC_DRAW);
            gameTexture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, gameTexture);
            gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, gameCanvas);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        }
        function renderWebGL(gameCanvas) {
            if (!gl) return;
            gl.uniform1f(pixelSizeUniformLocation, pixelSize);
            gl.bindTexture(gl.TEXTURE_2D, gameTexture);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, gameCanvas);
            gl.clearColor(0.0, 0.0, 0.0, 1.0); gl.clear(gl.COLOR_BUFFER_BIT);
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            const posAttrib = gl.getAttribLocation(shaderProgram, 'aVertexPosition');
            gl.vertexAttribPointer(posAttrib, 2, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(posAttrib);
            gl.bindBuffer(gl.ARRAY_BUFFER, textureCoordBuffer);
            const texAttrib = gl.getAttribLocation(shaderProgram, 'aTextureCoord');
            gl.vertexAttribPointer(texAttrib, 2, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(texAttrib);
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, gameTexture);
            gl.uniform1i(gl.getUniformLocation(shaderProgram, 'uSampler'), 0);
            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
        }
        function loadShader(gl, type, source) {
            const shader = gl.createShader(type); gl.shaderSource(shader, source); gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Shader error: ' + gl.getShaderInfoLog(shader)); gl.deleteShader(shader); return null;
            } return shader;
        }

        // --- 主执行逻辑 ---
        function startPostProcessingLoop() {
            const gameCanvas = document.getElementById('canvas');
            if (!gameCanvas) { setTimeout(startPostProcessingLoop, 100); return; }
            initWebGL(gameCanvas);
            function loop() {
                renderWebGL(gameCanvas);
                requestAnimationFrame(loop);
            }
            requestAnimationFrame(loop);
        }

        // 页面加载完毕后，启动我们的并行渲染循环
        window.addEventListener('load', startPostProcessingLoop);

        // 阻止右键菜单
        document.getElementById('fx-canvas').addEventListener('contextmenu', e => e.preventDefault());
    </script>
</body>
</html>